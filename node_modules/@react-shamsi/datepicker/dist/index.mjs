// src/Datepicker.tsx
import {
  flip,
  autoUpdate as floatingUiAutoUpdate,
  shift,
  useFloating
} from "@floating-ui/react-dom";
import { FloatingPortal } from "@floating-ui/react-dom-interactions";
import { useClickOutside } from "@mantine/hooks";
import { Calendar } from "@react-shamsi/calendar";
import { format } from "date-fns-jalali";
import { convertDigits } from "persian-helpers";
import { useEffect, useState } from "react";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
var DatePicker = ({
  autoUpdate,
  calendarProps,
  onChange,
  defaultDate,
  dateFormat = "yyyy/MM/dd hh:mm:ss aaa",
  date: controlledDate,
  to,
  persianDigits,
  calendarPortalElement,
  experimental_ranged: ranged,
  ...props
}) => {
  const { x, y, reference, floating, strategy } = useFloating({
    placement: "bottom-end",
    strategy: "absolute",
    middleware: [flip(), shift({ crossAxis: true })],
    whileElementsMounted: floatingUiAutoUpdate
  });
  const rangeToDate = (input, get) => Array.isArray(input) ? input[get === "from" ? 0 : 1] : input;
  const [date, setDate] = useState(
    rangeToDate(defaultDate, "to") || rangeToDate(controlledDate, "to")
  );
  const [fromDate, setFromDate] = useState(
    rangeToDate(defaultDate, "from") || rangeToDate(controlledDate, "from")
  );
  const [isOpen, setIsOpen] = useState(false);
  const [inputRef, setInputRef] = useState(null);
  const [calendarRef, setCalendarRef] = useState(null);
  useClickOutside(() => setIsOpen(false), null, [calendarRef, inputRef]);
  const updateDateHandler = (newDate, calendarFromDate) => {
    if (!controlledDate) {
      setDate(newDate);
      setFromDate(calendarFromDate);
    }
    if (ranged && calendarFromDate)
      onChange == null ? void 0 : onChange(calendarFromDate, newDate);
    else
      onChange == null ? void 0 : onChange(newDate);
  };
  const [isMounted, setIsMounted] = useState(false);
  useEffect(() => setIsMounted(true), []);
  useEffect(() => {
    if (!isMounted)
      return;
    setDate(rangeToDate(controlledDate, "to"));
    if (ranged)
      setFromDate(rangeToDate(controlledDate, "from"));
  }, [controlledDate]);
  const CalendarComponent = /* @__PURE__ */ jsx(Calendar, {
    ranged: Array.isArray(controlledDate) ? { from: controlledDate[0], to: controlledDate[1] } : ranged ? true : void 0,
    activeDate: Array.isArray(date) ? date[0] : date,
    onChange: (newDate, calendarFromDate) => autoUpdate && updateDateHandler(newDate, calendarFromDate),
    ref: (el) => {
      floating(el);
      setCalendarRef(el);
    },
    style: {
      position: strategy,
      top: y ?? 0,
      left: x ?? 0
    },
    showFooter: true,
    onConfirm: (newDate, calendarFromDate) => {
      updateDateHandler(newDate, calendarFromDate);
      setIsOpen(false);
    },
    onCancel: () => setIsOpen(false),
    ...calendarProps
  });
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [
      /* @__PURE__ */ jsx("div", {
        ref: setInputRef,
        children: /* @__PURE__ */ jsx("input", {
          ref: reference,
          className: "p-2 rounded-md border border-gray-300",
          value: date ? `${fromDate ? convertDigits(format(fromDate, dateFormat), {
            to: persianDigits ? "fa" : "en"
          }) + " - " : ""} ${convertDigits(format(date, dateFormat), {
            to: persianDigits ? "fa" : "en"
          })}` : "",
          readOnly: true,
          onClick: (event) => {
            var _a;
            setIsOpen(
              (previousIsOpen) => previousIsOpen === false ? true : previousIsOpen
            );
            (_a = props.onClick) == null ? void 0 : _a.call(props, event);
          },
          ...props
        })
      }),
      calendarPortalElement ? /* @__PURE__ */ jsx(FloatingPortal, {
        root: calendarPortalElement,
        children: isOpen && CalendarComponent
      }) : isOpen && CalendarComponent
    ]
  });
};
export {
  DatePicker
};
